Отлично. Ниже 15 задач. Для каждой — три варианта, которые **нужно реализовать** с разной асимптотикой: `O(1)`, `O(log n)`, `O(n)`. **Решения не показываю**, только формулировки и условия.

---

## 1) Минимум в массиве

* **O(1):** массив заранее **отсортирован по возрастанию** — вернуть минимум.
* **O(log n):** массив **отсортирован и повернут** (rotated sorted) — найти минимум.
* **O(n):** массив произвольный — найти минимум полным проходом.

## 2) Проверка чётности числа

* **O(1):** по биту/остатку определить чётность.
* **O(log n):** многократно делить число на 2, пока не дойдёшь до базового случая.
* **O(n):** вычитать 1/2 последовательно (искусственно усложнённый линейный подход).

## 3) Входит ли элемент в структуру

* **O(1):** структура — **hash set**; проверить наличие.
* **O(log n):** структура — **отсортированный массив**; бинарный поиск.
* **O(n):** структура — **несортированный список**; линейный поиск.

## 4) Первый неповторяющийся символ в строке

* **O(1):** алфавит ограничен, заранее доступна **таблица частот фиксированного размера**.
* **O(log n):** строка дана как **массив (символ, частота)**, отсортированный по символу; ищи с бинарным поиском по символу и проверками.
* **O(n):** один-два прохода по строке с подсчётом частот.

## 5) Нахождение k-го по величине (k=1 — минимум)

* **O(1):** массив отсортирован по возрастанию; k-й — это индексированное обращение.
* **O(log n):** массив — **две отсортированные половины**; используй деление и логарифмическое слияние до k-го.
* **O(n):** несортированный массив — однопроходные методы выбора/скан с буферами (без полной сортировки).

## 6) Проверка отсортированности массива

* **O(1):** хранится флаг «массив отсортирован» вместе с массивом.
* **O(log n):** проверка по **репрезентативным точкам** (границе/середина) при условии монотонности блоков.
* **O(n):** пройти массив и убедиться `a[i] ≤ a[i+1]`.

## 7) Подсчёт количества элементов меньше x

* **O(1):** массив заранее отсортирован, и для часто используемых x хранится предвычисленная таблица ответов.
* **O(log n):** отсортированный массив; найди первую позицию `>= x` бинарным поиском.
* **O(n):** произвольный массив; пройтись и посчитать.

## 8) Сумма первых n элементов

* **O(1):** доступна **префиксная сумма** или формула; вернуть из кэша/по формуле.
* **O(log n):** хранится **Fenwick/BIT** или дерево отрезков; запрос суммы — логарифм.
* **O(n):** просто сложить первые n элементов.

## 9) Поиск границы «истина-ложь» в булевом массиве

(Сначала идут `False`, потом `True`.)

* **O(1):** индекс границы заранее известен/кэширован.
* **O(log n):** бинарный поиск по переходу `False→True`.
* **O(n):** линейный поиск от начала.

## 10) Проверка наличия дубликатов

* **O(1):** вход гарантированно «без дубликатов» и это подтверждено метаданными.
* **O(log n):** данные — **отсортированный массив**; проверь соседние пары бинарным «разбиением» на сегменты.
* **O(n):** пробег с хеш-набором или сортировка и один проход.

## 11) Найти ближайшее к x число в массиве

* **O(1):** массив отсортирован, а x всегда в **фиксированном наборе значений**; ответ — из предрасчитанной таблицы.
* **O(log n):** массив отсортирован; ищется позиция вставки бинарным поиском, после — сравнение соседей.
* **O(n):** произвольный массив; полный проход с минимумом по |a\[i]-x|.

## 12) Проверка подстроки в строке

* **O(1):** подстрока — из небольшого фиксированного алфавита и фиксированной длины; используем прямой индекс (хеш-таблица фиксированного размера).
* **O(log n):** строка представлена **суффиксным массивом**; бинарный поиск по лексикографическому порядку.
* **O(n):** наивный поиск или сканирование по роллинг-хешу без индекса (без «preprocessing»).

## 13) Количество элементов в диапазоне \[L, R]

* **O(1):** есть **префиксные суммы частот**; ответ = pref\[R] - pref\[L-1].
* **O(log n):** отсортированный массив; две границы бинарным поиском.
* **O(n):** произвольный массив; пройти и посчитать.

## 14) Поиск первого элемента, превышающего порог T

* **O(1):** значение и индекс поддерживаются в живом кэше/сигнале инкрементально.
* **O(log n):** отсортированный по неубыванию массив; бинарный поиск первой позиции `> T`.
* **O(n):** несортированный массив; линейный проход.

## 15) Проверка, есть ли пара с суммой S

* **O(1):** известен заранее набор допустимых сумм для часто встречающихся S; ответ из таблицы.
* **O(log n):** массив отсортирован; для каждого i делай бинарный поиск `S - a[i]`.
* **O(n):** один проход с хеш-набором “виденных” элементов.

---

Хочешь, дальше выберем 3–5 задач из списка и я дам тебе **пошаговый разбор** (без кода → с подсказками → с кодом), чтобы ты сам дошёл до решений нужной сложности?
